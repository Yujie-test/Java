package day03;/*
	关于java语言当中的整数型：
		byte、short、int、long
	1、java语言当中的“整数型字面值”被默认当作int类型来处理，要让这个”整数型字面值“被当作long类型来处理的话，需要在”整数型字面值“后面添加l/L，建议使用大写的L
	2、java语言当中的整数型字面值有三种表示方式：
		第一种方式：十进制「是一种缺省默认的方式」
		第二种方式：八进制「在编写八进制整数型字面值的时候需要以0开始」
		第三种方式：十六进制「在编写十六进制整数型字面值的时候需要以0x开始」
*/

public class DataTypeTest05{

	public static void main(String[] args){

		//100L是long类型字面值，x是long类型变量，不存在类型转换，直接赋值

		long x = 100L;

		//x是long类型变量，8个字节
		//y是int类型变量，4个字节
		//编译错误：不兼容的类型: 从long转换到int可能会有损失
		//大容量不能直接赋值给小容量

		//int y = x;

		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加“强制类型转换符”
		//加上强制类型转换符后编译通过了，但是运行阶段可能损失精度
		//所以强制类型转换谨慎使用，因为损失精度之后可能损失很严重
		//强转原理：
			//原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
			//强转之后的数据：00000000 00000000 00000000 01100100
			//将左边的二进制位砍掉「所有的数据强转的时候都是这样完成的」

		int y = (int)x;
		System.out.println(y);

		//原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		//强转之后的数据：10000000 00000000 00000000 00000000，是一个补码形式
		//将以上的补码转换成原码就是最终结果
		long k = 2147483648L;
		int e = (int)k;
		System.out.println(e); //损失精度严重，结果是负数「-2147483648」

		//依照现在知识，50是int类型字面值，b是byte类型变量，大容量转换成小容量需要添加强制转换符
		//实际没有报错,这说明在java语言当中，当一个整数型字面值没有超出byte类型取值范围的话，该字面值可以直接复制给byte类型的变量
		byte b = 50;
		System.out.println(b);
		byte c = 127;
		// 编译报错，128这个int类型的字面值已经超出了byte类型的取值范围，不能直接赋值给byte类型的变量
		// byte b1 = 128;

		// 纠正错误，需要使用强制类型转换符
		// 但是一定会损失精度
		// 原始数据：00000000 00000000 00000000 10000000
		// 强转之后：10000000「这是存储在计算机内部的，这是一个补码，他的原 码是什么？」
		byte b1 = (byte)128; // -128
		System.out.println(b1);
		/*
		计算机二进制有三种表示形式：
			原码
			反码
			补码
		计算机在任何情况下底层表示和存储数据的时候采用了补码形式
		正数的补码：和原码相同
		负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加1

		补码：10000000
		原码的计算过程：
			* 1000000 - 1 --> 01111111
			* 10000000 --> 128
			* -128
		*/
		byte m = (byte)198;
		System.out.println(m);
		/*
		补码：198 --> 11000110
		原码：补码减1 --> 198 -1 = 197 --> 11000101
			 取反 --> 00111010 --> 58
			 符号位取反 --> -58
		*/
		short s = 32767;  // 通过
		//short s1 = 32768; // 编译报错

		// 65535是int类型，4个字节
		// cc是char类型，2个字节
		char cc = 65535;
		// char cc1 = 65536;

		/*
		当一个整数字面值没有超出byte，short，char的取值范围，这个字面值可以直接赋值给byte，short，char类型的变量
		这种机制SUN允许了，目的是为了方便程序员编程
		*/
	}
}

